<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMS Backend API Development Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        
        h4 {
            color: #34495e;
            margin-top: 20px;
        }
        
        h5 {
            color: #7f8c8d;
            margin-top: 15px;
        }
        
        code {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 3px;
            padding: 2px 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        pre code {
            background: none;
            border: none;
            padding: 0;
        }
        
        ul, ol {
            margin-left: 20px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding-left: 20px;
            color: #7f8c8d;
            font-style: italic;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .toc {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .toc h2 {
            margin-top: 0;
            border-bottom: none;
        }
        
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .toc li {
            margin-bottom: 8px;
        }
        
        .toc a {
            text-decoration: none;
            color: #3498db;
        }
        
        .toc a:hover {
            text-decoration: underline;
        }
        
        .highlight {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .warning {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>EMS Backend API Development Guide</h1>
    
    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#architecture">1. Project Architecture Overview</a></li>
            <li><a href="#prerequisites">2. Prerequisites</a></li>
            <li><a href="#step-by-step">3. Step-by-Step API Creation Process</a></li>
            <li><a href="#examples">4. Code Examples</a></li>
            <li><a href="#best-practices">5. Best Practices</a></li>
            <li><a href="#testing">6. Testing</a></li>
            <li><a href="#troubleshooting">7. Troubleshooting</a></li>
        </ul>
    </div>

    <p>This guide provides step-by-step instructions for creating new APIs in the EMS (Education Management System) backend project. The project follows Clean Architecture principles with clear separation of concerns across multiple layers.</p>

    <h2 id="architecture">Project Architecture Overview</h2>
    
    <p>The EMS backend follows Clean Architecture with the following layers:</p>
    
    <pre><code>EMS.API/           - Controllers and API endpoints
EMS.Application/   - Business logic and services
EMS.Domain/        - Entities, interfaces, and domain models
EMS.Infrastructure/ - Data access and external services
EMS.EFCore/        - Database context and configurations</code></pre>

    <h3>Key Patterns Used:</h3>
    <ul>
        <li><strong>Repository Pattern</strong> - Data access abstraction</li>
        <li><strong>Unit of Work Pattern</strong> - Transaction management</li>
        <li><strong>Service Layer Pattern</strong> - Business logic encapsulation</li>
        <li><strong>DTO Pattern</strong> - Data transfer objects</li>
        <li><strong>Dependency Injection</strong> - IoC container management</li>
    </ul>

    <h2 id="prerequisites">Prerequisites</h2>
    
    <p>Before creating a new API, ensure you have:</p>
    
    <h3>1. Development Environment Setup</h3>
    <ul>
        <li>.NET 8.0 SDK</li>
        <li>PostgreSQL database</li>
        <li>Visual Studio 2022 or VS Code</li>
        <li>Git</li>
    </ul>

    <h3>2. Project Dependencies</h3>
    <ul>
        <li>Entity Framework Core</li>
        <li>AutoMapper (Mapperly)</li>
        <li>LanguageExt (for Result pattern)</li>
        <li>Scrutor (for dependency scanning)</li>
        <li>Serilog (for logging)</li>
    </ul>

    <h2 id="step-by-step">Step-by-Step API Creation Process</h2>

    <h3>Step 1: Create the Domain Entity</h3>
    
    <p>First, create your entity in the <code>EMS.Domain/Entities/</code> folder:</p>
    
    <pre><code>// EMS.Domain/Entities/YourEntity.cs
using EMS.Domain.Entities.Base;
using System.ComponentModel.DataAnnotations;

namespace EMS.Domain.Entities;

public class YourEntity : AuditableEntity
{
    [Required]
    public string Name { get; set; } = string.Empty;
    
    public string? Description { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    // Foreign key relationships
    public Guid? ParentId { get; set; }
    public YourEntity? Parent { get; set; }
}</code></pre>

    <div class="highlight">
        <strong>Key Points:</strong>
        <ul>
            <li>Always inherit from <code>AuditableEntity</code> for audit fields</li>
            <li>Use <code>[Required]</code> for mandatory fields</li>
            <li>Include navigation properties for relationships</li>
        </ul>
    </div>

    <h3>Step 2: Create the Repository Interface</h3>
    
    <p>Create the repository interface in <code>EMS.Domain/Interfaces/Repositories/</code>:</p>
    
    <pre><code>// EMS.Domain/Interfaces/Repositories/IYourEntityRepository.cs
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.Repositories.Base;

namespace EMS.Domain.Interfaces.Repositories;

public interface IYourEntityRepository : IAuditRepository&lt;YourEntity&gt;
{
    // Add custom repository methods if needed
    Task&lt;YourEntity?&gt; GetByNameAsync(string name);
    Task&lt;List&lt;YourEntity&gt;&gt; GetActiveEntitiesAsync();
}</code></pre>

    <h3>Step 3: Create the Repository Implementation</h3>
    
    <p>Implement the repository in <code>EMS.Infrastructure/Repositories/</code>:</p>
    
    <pre><code>// EMS.Infrastructure/Repositories/YourEntityRepository.cs
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.Repositories;
using EMS.Infrastructure.DataAccess;
using EMS.Infrastructure.Repositories.Base;

namespace EMS.Infrastructure.Repositories;

public class YourEntityRepository(DbFactory dbFactory) 
    : AuditRepository&lt;YourEntity&gt;(dbFactory), IYourEntityRepository
{
    public async Task&lt;YourEntity?&gt; GetByNameAsync(string name)
    {
        return await GetFirstNotDeletedAsync(x =&gt; x.Name == name);
    }

    public async Task&lt;List&lt;YourEntity&gt;&gt; GetActiveEntitiesAsync()
    {
        return await ListAsync(query =&gt; query.Where(x =&gt; x.IsActive));
    }
}</code></pre>

    <h3>Step 4: Create the Service Interface</h3>
    
    <p>Create the service interface in <code>EMS.Application/Services/YourEntityServices/</code>:</p>
    
    <pre><code>// EMS.Application/Services/YourEntityServices/IYourEntityService.cs
using EMS.Application.Services.Base;
using EMS.Domain.Entities;

namespace EMS.Application.Services.YourEntityServices;

public interface IYourEntityService : IBaseService&lt;YourEntity&gt;
{
    // Add custom service methods if needed
    Task&lt;Result&lt;YourEntity&gt;&gt; CreateWithValidationAsync(YourEntity entity);
    Task&lt;Result&lt;List&lt;YourEntity&gt;&gt;&gt; GetActiveEntitiesAsync();
}</code></pre>

    <h3>Step 5: Create the Service Implementation</h3>
    
    <p>Implement the service in <code>EMS.Application/Services/YourEntityServices/</code>:</p>
    
    <pre><code>// EMS.Application/Services/YourEntityServices/YourEntityService.cs
using EMS.Application.Services.Base;
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.DataAccess;
using EMS.Domain.Interfaces.Repositories;
using LanguageExt.Common;

namespace EMS.Application.Services.YourEntityServices;

public class YourEntityService : BaseService&lt;YourEntity&gt;, IYourEntityService
{
    private readonly IYourEntityRepository _repository;

    public YourEntityService(IUnitOfWork unitOfWork, IYourEntityRepository repository) 
        : base(unitOfWork, repository)
    {
        _repository = repository;
    }

    public async Task&lt;Result&lt;YourEntity&gt;&gt; CreateWithValidationAsync(YourEntity entity)
    {
        // Add custom business logic here
        var existing = await _repository.GetByNameAsync(entity.Name);
        if (existing != null)
        {
            return new Result&lt;YourEntity&gt;(new ConflictException("Entity with this name already exists"));
        }

        return await CreateAsync(entity);
    }

    public async Task&lt;Result&lt;List&lt;YourEntity&gt;&gt;&gt; GetActiveEntitiesAsync()
    {
        try
        {
            var entities = await _repository.GetActiveEntitiesAsync();
            return new Result&lt;List&lt;YourEntity&gt;&gt;(entities);
        }
        catch (Exception ex)
        {
            return new Result&lt;List&lt;YourEntity&gt;&gt;(ex);
        }
    }

    protected override Task UpdateEntityProperties(YourEntity existingEntity, YourEntity newEntity)
    {
        existingEntity.Name = newEntity.Name;
        existingEntity.Description = newEntity.Description;
        existingEntity.IsActive = newEntity.IsActive;
        existingEntity.ParentId = newEntity.ParentId;

        return Task.CompletedTask;
    }
}</code></pre>

    <h3>Step 6: Create DTOs (Optional but Recommended)</h3>
    
    <p>Create DTOs for complex operations in <code>EMS.Application/Services/YourEntityServices/Dtos/</code>:</p>
    
    <pre><code>// EMS.Application/Services/YourEntityServices/Dtos/CreateYourEntityRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace EMS.Application.Services.YourEntityServices.Dtos;

public class CreateYourEntityRequestDto
{
    [Required]
    [StringLength(100)]
    public string Name { get; set; } = string.Empty;
    
    [StringLength(500)]
    public string? Description { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    public Guid? ParentId { get; set; }
}</code></pre>

    <pre><code>// EMS.Application/Services/YourEntityServices/Dtos/YourEntityDto.cs
namespace EMS.Application.Services.YourEntityServices.Dtos;

public class YourEntityDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public bool IsActive { get; set; }
    public Guid? ParentId { get; set; }
    public DateTime NgayTao { get; set; }
    public DateTime NgayCapNhat { get; set; }
}</code></pre>

    <h3>Step 7: Create Mappers (Optional)</h3>
    
    <p>Create mappers using Mapperly in <code>EMS.Application/Services/YourEntityServices/Mappers/</code>:</p>
    
    <pre><code>// EMS.Application/Services/YourEntityServices/Mappers/YourEntityMapper.cs
using EMS.Application.Services.YourEntityServices.Dtos;
using EMS.Domain.Entities;
using Riok.Mapperly.Abstractions;

namespace EMS.Application.Services.YourEntityServices.Mappers;

[Mapper]
public partial class YourEntityMapper
{
    public static partial YourEntityDto ToYourEntityDto(YourEntity entity);
    public static partial List&lt;YourEntityDto&gt; ToYourEntityDtoList(List&lt;YourEntity&gt; entities);
}</code></pre>

    <h3>Step 8: Create the Controller</h3>
    
    <p>Create the controller in <code>EMS.API/Controllers/</code>:</p>
    
    <h4>Option A: Simple Controller (inherits from BaseController)</h4>
    <pre><code>// EMS.API/Controllers/YourEntityController.cs
using EMS.Application.Services.YourEntityServices;
using EMS.Domain.Entities;
using EMS.API.Controllers.Base;

namespace EMS.API.Controllers;

public class YourEntityController : BaseController&lt;YourEntity&gt;
{
    public YourEntityController(IYourEntityService yourEntityService) : base(yourEntityService)
    {
    }
}</code></pre>

    <h4>Option B: Custom Controller (for complex operations)</h4>
    <pre><code>// EMS.API/Controllers/YourEntityController.cs
using EMS.Application.Services.YourEntityServices;
using EMS.Application.Services.YourEntityServices.Dtos;
using EMS.Domain.Extensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace EMS.API.Controllers;

[Route("api/[controller]")]
[ApiController]
public class YourEntityController(IYourEntityService yourEntityService) : ControllerBase
{
    private readonly IYourEntityService _yourEntityService = yourEntityService;

    [HttpPost("custom")]
    [Authorize]
    public async Task&lt;IActionResult&gt; CreateCustomAsync([FromBody] CreateYourEntityRequestDto request)
    {
        var entity = new YourEntity
        {
            Name = request.Name,
            Description = request.Description,
            IsActive = request.IsActive,
            ParentId = request.ParentId
        };

        var result = await _yourEntityService.CreateWithValidationAsync(entity);
        return result.ToResult();
    }

    [HttpGet("active")]
    public async Task&lt;IActionResult&gt; GetActiveEntitiesAsync()
    {
        var result = await _yourEntityService.GetActiveEntitiesAsync();
        return result.ToResult();
    }
}</code></pre>

    <h3>Step 9: Create Database Configuration</h3>
    
    <p>Create the Entity Framework configuration in <code>EMS.EFCore/Configurations/</code>:</p>
    
    <pre><code>// EMS.EFCore/Configurations/YourEntityConfiguration.cs
using EMS.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace EMS.EFCore.Configurations;

public class YourEntityConfiguration : IEntityTypeConfiguration&lt;YourEntity&gt;
{
    public void Configure(EntityTypeBuilder&lt;YourEntity&gt; builder)
    {
        builder.HasKey(x =&gt; x.Id);

        builder.Property(x =&gt; x.Name)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(x =&gt; x.Description)
            .HasMaxLength(500);

        builder.Property(x =&gt; x.IsActive)
            .HasDefaultValue(true);

        // Configure relationships
        builder.HasOne(x =&gt; x.Parent)
            .WithMany()
            .HasForeignKey(x =&gt; x.ParentId)
            .OnDelete(DeleteBehavior.Restrict);

        // Configure indexes
        builder.HasIndex(x =&gt; x.Name).IsUnique();
        builder.HasIndex(x =&gt; x.IsActive);
    }
}</code></pre>

    <h3>Step 10: Register Dependencies</h3>
    
    <p>The project uses automatic dependency scanning with Scrutor, so most services and repositories are automatically registered. However, if you need manual registration, add them to the respective <code>DependencyInjection.cs</code> files:</p>
    
    <h4>For Services (EMS.Application/DependencyInjection.cs):</h4>
    <pre><code>// Add to ManualRegister method if needed
services.AddScoped&lt;IYourEntityService, YourEntityService&gt;();</code></pre>

    <h4>For Repositories (EMS.Infrastructure/DependencyInjection.cs):</h4>
    <pre><code>// Add to ManualRegister method if needed
services.AddScoped&lt;IYourEntityRepository, YourEntityRepository&gt;();</code></pre>

    <h3>Step 11: Create Database Migration</h3>
    
    <p>Run the following commands to create and apply the database migration:</p>
    
    <pre><code># Navigate to the project root
cd EMS-backend

# Create migration
dotnet ef migrations add AddYourEntity --project EMS.EFCore --startup-project EMS.API

# Update database
dotnet ef database update --project EMS.EFCore --startup-project EMS.API</code></pre>

    <h2 id="examples">Code Examples</h2>

    <h3>Complete Example: Student Management API</h3>
    
    <p>Here's a complete example of creating a Student management API:</p>

    <h4>1. Entity</h4>
    <pre><code>// EMS.Domain/Entities/Student.cs
using EMS.Domain.Entities.Base;
using System.ComponentModel.DataAnnotations;

namespace EMS.Domain.Entities;

public class Student : AuditableEntity
{
    [Required]
    public string StudentCode { get; set; } = string.Empty;
    
    [Required]
    public string FirstName { get; set; } = string.Empty;
    
    [Required]
    public string LastName { get; set; } = string.Empty;
    
    public string? Email { get; set; }
    
    public DateTime? DateOfBirth { get; set; }
    
    public Guid ClassId { get; set; }
    public Class? Class { get; set; }
}</code></pre>

    <h4>2. Repository Interface</h4>
    <pre><code>// EMS.Domain/Interfaces/Repositories/IStudentRepository.cs
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.Repositories.Base;

namespace EMS.Domain.Interfaces.Repositories;

public interface IStudentRepository : IAuditRepository&lt;Student&gt;
{
    Task&lt;Student?&gt; GetByStudentCodeAsync(string studentCode);
    Task&lt;List&lt;Student&gt;&gt; GetByClassIdAsync(Guid classId);
}</code></pre>

    <h4>3. Repository Implementation</h4>
    <pre><code>// EMS.Infrastructure/Repositories/StudentRepository.cs
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.Repositories;
using EMS.Infrastructure.DataAccess;
using EMS.Infrastructure.Repositories.Base;

namespace EMS.Infrastructure.Repositories;

public class StudentRepository(DbFactory dbFactory) 
    : AuditRepository&lt;Student&gt;(dbFactory), IStudentRepository
{
    public async Task&lt;Student?&gt; GetByStudentCodeAsync(string studentCode)
    {
        return await GetFirstNotDeletedAsync(x =&gt; x.StudentCode == studentCode);
    }

    public async Task&lt;List&lt;Student&gt;&gt; GetByClassIdAsync(Guid classId)
    {
        return await ListAsync(query =&gt; query.Where(x =&gt; x.ClassId == classId));
    }
}</code></pre>

    <h4>4. Service Interface</h4>
    <pre><code>// EMS.Application/Services/StudentServices/IStudentService.cs
using EMS.Application.Services.Base;
using EMS.Domain.Entities;

namespace EMS.Application.Services.StudentServices;

public interface IStudentService : IBaseService&lt;Student&gt;
{
    Task&lt;Result&lt;Student&gt;&gt; CreateStudentAsync(CreateStudentRequestDto request);
    Task&lt;Result&lt;List&lt;Student&gt;&gt;&gt; GetStudentsByClassAsync(Guid classId);
}</code></pre>

    <h4>5. Service Implementation</h4>
    <pre><code>// EMS.Application/Services/StudentServices/StudentService.cs
using EMS.Application.Services.Base;
using EMS.Application.Services.StudentServices.Dtos;
using EMS.Domain.Entities;
using EMS.Domain.Exceptions;
using EMS.Domain.Interfaces.DataAccess;
using EMS.Domain.Interfaces.Repositories;
using LanguageExt.Common;

namespace EMS.Application.Services.StudentServices;

public class StudentService : BaseService&lt;Student&gt;, IStudentService
{
    private readonly IStudentRepository _studentRepository;

    public StudentService(IUnitOfWork unitOfWork, IStudentRepository studentRepository) 
        : base(unitOfWork, studentRepository)
    {
        _studentRepository = studentRepository;
    }

    public async Task&lt;Result&lt;Student&gt;&gt; CreateStudentAsync(CreateStudentRequestDto request)
    {
        var existingStudent = await _studentRepository.GetByStudentCodeAsync(request.StudentCode);
        if (existingStudent != null)
        {
            return new Result&lt;Student&gt;(new ConflictException("Student with this code already exists"));
        }

        var student = new Student
        {
            StudentCode = request.StudentCode,
            FirstName = request.FirstName,
            LastName = request.LastName,
            Email = request.Email,
            DateOfBirth = request.DateOfBirth,
            ClassId = request.ClassId
        };

        return await CreateAsync(student);
    }

    public async Task&lt;Result&lt;List&lt;Student&gt;&gt;&gt; GetStudentsByClassAsync(Guid classId)
    {
        try
        {
            var students = await _studentRepository.GetByClassIdAsync(classId);
            return new Result&lt;List&lt;Student&gt;&gt;(students);
        }
        catch (Exception ex)
        {
            return new Result&lt;List&lt;Student&gt;&gt;(ex);
        }
    }

    protected override Task UpdateEntityProperties(Student existingEntity, Student newEntity)
    {
        existingEntity.StudentCode = newEntity.StudentCode;
        existingEntity.FirstName = newEntity.FirstName;
        existingEntity.LastName = newEntity.LastName;
        existingEntity.Email = newEntity.Email;
        existingEntity.DateOfBirth = newEntity.DateOfBirth;
        existingEntity.ClassId = newEntity.ClassId;

        return Task.CompletedTask;
    }
}</code></pre>

    <h4>6. DTOs</h4>
    <pre><code>// EMS.Application/Services/StudentServices/Dtos/CreateStudentRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace EMS.Application.Services.StudentServices.Dtos;

public class CreateStudentRequestDto
{
    [Required]
    [StringLength(20)]
    public string StudentCode { get; set; } = string.Empty;
    
    [Required]
    [StringLength(50)]
    public string FirstName { get; set; } = string.Empty;
    
    [Required]
    [StringLength(50)]
    public string LastName { get; set; } = string.Empty;
    
    [EmailAddress]
    public string? Email { get; set; }
    
    public DateTime? DateOfBirth { get; set; }
    
    [Required]
    public Guid ClassId { get; set; }
}</code></pre>

    <h4>7. Controller</h4>
    <pre><code>// EMS.API/Controllers/StudentController.cs
using EMS.Application.Services.StudentServices;
using EMS.Application.Services.StudentServices.Dtos;
using EMS.Domain.Extensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace EMS.API.Controllers;

[Route("api/[controller]")]
[ApiController]
public class StudentController(IStudentService studentService) : ControllerBase
{
    private readonly IStudentService _studentService = studentService;

    [HttpPost]
    [Authorize]
    public async Task&lt;IActionResult&gt; CreateStudentAsync([FromBody] CreateStudentRequestDto request)
    {
        var result = await _studentService.CreateStudentAsync(request);
        return result.ToResult();
    }

    [HttpGet("class/{classId:guid}")]
    public async Task&lt;IActionResult&gt; GetStudentsByClassAsync(Guid classId)
    {
        var result = await _studentService.GetStudentsByClassAsync(classId);
        return result.ToResult();
    }
}</code></pre>

    <h4>8. Database Configuration</h4>
    <pre><code>// EMS.EFCore/Configurations/StudentConfiguration.cs
using EMS.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace EMS.EFCore.Configurations;

public class StudentConfiguration : IEntityTypeConfiguration&lt;Student&gt;
{
    public void Configure(EntityTypeBuilder&lt;Student&gt; builder)
    {
        builder.HasKey(x =&gt; x.Id);

        builder.Property(x =&gt; x.StudentCode)
            .IsRequired()
            .HasMaxLength(20);

        builder.Property(x =&gt; x.FirstName)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(x =&gt; x.LastName)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(x =&gt; x.Email)
            .HasMaxLength(100);

        builder.HasOne(x =&gt; x.Class)
            .WithMany()
            .HasForeignKey(x =&gt; x.ClassId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasIndex(x =&gt; x.StudentCode).IsUnique();
        builder.HasIndex(x =&gt; x.Email);
        builder.HasIndex(x =&gt; x.ClassId);
    }
}</code></pre>

    <h2 id="best-practices">Best Practices</h2>

    <h3>1. Naming Conventions</h3>
    <ul>
        <li><strong>Entities</strong>: PascalCase, singular (e.g., <code>Student</code>, <code>Course</code>)</li>
        <li><strong>Controllers</strong>: PascalCase + "Controller" suffix (e.g., <code>StudentController</code>)</li>
        <li><strong>Services</strong>: PascalCase + "Service" suffix (e.g., <code>StudentService</code>)</li>
        <li><strong>Repositories</strong>: PascalCase + "Repository" suffix (e.g., <code>StudentRepository</code>)</li>
        <li><strong>DTOs</strong>: PascalCase + descriptive suffix (e.g., <code>CreateStudentRequestDto</code>)</li>
    </ul>

    <h3>2. Error Handling</h3>
    <ul>
        <li>Use the <code>Result&lt;T&gt;</code> pattern for consistent error handling</li>
        <li>Throw appropriate domain exceptions (<code>NotFoundException</code>, <code>ConflictException</code>, etc.)</li>
        <li>Always handle exceptions in service methods</li>
    </ul>

    <h3>3. Validation</h3>
    <ul>
        <li>Use data annotations for input validation</li>
        <li>Implement business rule validation in services</li>
        <li>Validate foreign key relationships</li>
    </ul>

    <h3>4. Security</h3>
    <ul>
        <li>Use <code>[Authorize]</code> attribute for protected endpoints</li>
        <li>Validate user permissions in service methods</li>
        <li>Sanitize input data</li>
    </ul>

    <h3>5. Performance</h3>
    <ul>
        <li>Use async/await patterns consistently</li>
        <li>Implement proper indexing in database configurations</li>
        <li>Use pagination for large datasets</li>
        <li>Consider caching for frequently accessed data</li>
    </ul>

    <h3>6. Database Design</h3>
    <ul>
        <li>Always inherit from <code>AuditableEntity</code> for audit fields</li>
        <li>Use appropriate data types and constraints</li>
        <li>Implement proper foreign key relationships</li>
        <li>Add indexes for frequently queried columns</li>
    </ul>

    <h2 id="testing">Testing</h2>

    <h3>Unit Testing</h3>
    
    <p>Create unit tests for your services:</p>
    
    <pre><code>// Tests/EMS.Application.Tests/Services/StudentServiceTests.cs
using EMS.Application.Services.StudentServices;
using EMS.Domain.Entities;
using EMS.Domain.Interfaces.DataAccess;
using EMS.Domain.Interfaces.Repositories;
using Moq;
using Xunit;

namespace EMS.Application.Tests.Services;

public class StudentServiceTests
{
    private readonly Mock&lt;IUnitOfWork&gt; _unitOfWorkMock;
    private readonly Mock&lt;IStudentRepository&gt; _studentRepositoryMock;
    private readonly StudentService _studentService;

    public StudentServiceTests()
    {
        _unitOfWorkMock = new Mock&lt;IUnitOfWork&gt;();
        _studentRepositoryMock = new Mock&lt;IStudentRepository&gt;();
        _studentService = new StudentService(_unitOfWorkMock.Object, _studentRepositoryMock.Object);
    }

    [Fact]
    public async Task CreateStudentAsync_WithValidData_ShouldReturnSuccess()
    {
        // Arrange
        var request = new CreateStudentRequestDto
        {
            StudentCode = "STU001",
            FirstName = "John",
            LastName = "Doe",
            ClassId = Guid.NewGuid()
        };

        _studentRepositoryMock.Setup(x =&gt; x.GetByStudentCodeAsync(request.StudentCode))
            .ReturnsAsync((Student?)null);

        // Act
        var result = await _studentService.CreateStudentAsync(request);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(request.StudentCode, result.Value.StudentCode);
    }
}</code></pre>

    <h3>Integration Testing</h3>
    
    <p>Create integration tests for your controllers:</p>
    
    <pre><code>// Tests/EMS.API.Tests/Controllers/StudentControllerTests.cs
using EMS.API.Controllers;
using EMS.Application.Services.StudentServices;
using EMS.Application.Services.StudentServices.Dtos;
using Microsoft.AspNetCore.Mvc;
using Moq;
using Xunit;

namespace EMS.API.Tests.Controllers;

public class StudentControllerTests
{
    private readonly Mock&lt;IStudentService&gt; _studentServiceMock;
    private readonly StudentController _controller;

    public StudentControllerTests()
    {
        _studentServiceMock = new Mock&lt;IStudentService&gt;();
        _controller = new StudentController(_studentServiceMock.Object);
    }

    [Fact]
    public async Task CreateStudent_WithValidData_ShouldReturnOk()
    {
        // Arrange
        var request = new CreateStudentRequestDto
        {
            StudentCode = "STU001",
            FirstName = "John",
            LastName = "Doe",
            ClassId = Guid.NewGuid()
        };

        var student = new Student { StudentCode = request.StudentCode };
        _studentServiceMock.Setup(x =&gt; x.CreateStudentAsync(request))
            .ReturnsAsync(new Result&lt;Student&gt;(student));

        // Act
        var result = await _controller.CreateStudentAsync(request);

        // Assert
        Assert.IsType&lt;OkObjectResult&gt;(result);
    }
}</code></pre>

    <h2 id="troubleshooting">Troubleshooting</h2>

    <h3>Common Issues and Solutions</h3>

    <h4>1. Dependency Injection Errors</h4>
    <div class="warning">
        <strong>Problem</strong>: Service not registered in DI container<br>
        <strong>Solution</strong>: Ensure your service implements the correct interface and follows naming conventions for automatic registration
    </div>

    <h4>2. Database Migration Issues</h4>
    <div class="warning">
        <strong>Problem</strong>: Migration fails or doesn't apply<br>
        <strong>Solution</strong>: 
        <ul>
            <li>Check connection string in <code>appsettings.json</code></li>
            <li>Ensure all entity configurations are properly set up</li>
            <li>Verify foreign key relationships</li>
        </ul>
    </div>

    <h4>3. Repository Not Found</h4>
    <div class="warning">
        <strong>Problem</strong>: Repository interface not found<br>
        <strong>Solution</strong>: Ensure repository interface is in the correct namespace and implements <code>IAuditRepository&lt;T&gt;</code>
    </div>

    <h4>4. Validation Errors</h4>
    <div class="warning">
        <strong>Problem</strong>: DTO validation not working<br>
        <strong>Solution</strong>: 
        <ul>
            <li>Check data annotations are properly applied</li>
            <li>Ensure <code>[ApiController]</code> attribute is present on controller</li>
            <li>Verify model binding attributes (<code>[FromBody]</code>, <code>[FromQuery]</code>, etc.)</li>
        </ul>
    </div>

    <h4>5. Authentication Issues</h4>
    <div class="warning">
        <strong>Problem</strong>: <code>[Authorize]</code> attribute not working<br>
        <strong>Solution</strong>: 
        <ul>
            <li>Ensure JWT configuration is correct in <code>Program.cs</code></li>
            <li>Check token is properly formatted and not expired</li>
            <li>Verify authentication middleware is registered before authorization</li>
        </ul>
    </div>

    <h3>Debugging Tips</h3>

    <h4>1. Enable Detailed Logging</h4>
    <pre><code>// In appsettings.Development.json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft": "Information",
        "System": "Warning"
      }
    }
  }
}</code></pre>

    <h4>2. Use Swagger for API Testing</h4>
    <ul>
        <li>Navigate to <code>/swagger</code> in development mode</li>
        <li>Test endpoints directly from the browser</li>
        <li>Verify request/response models</li>
    </ul>

    <h4>3. Database Query Logging</h4>
    <pre><code>// In AppDbContext.cs
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (Environment.IsDevelopment())
    {
        optionsBuilder.LogTo(Console.WriteLine);
    }
}</code></pre>

    <h2>Conclusion</h2>

    <p>This guide provides a comprehensive approach to creating new APIs in the EMS backend project. By following these patterns and best practices, you can ensure consistency, maintainability, and scalability of your codebase.</p>

    <div class="info">
        <strong>Remember to:</strong>
        <ul>
            <li>Always follow the established patterns</li>
            <li>Write comprehensive tests</li>
            <li>Document your APIs properly</li>
            <li>Consider performance implications</li>
            <li>Implement proper error handling</li>
            <li>Follow security best practices</li>
        </ul>
    </div>

    <p>For additional help or questions, refer to the existing codebase examples or consult with the development team.</p>

    <hr>
    <p><em>Generated from API_DEVELOPMENT_GUIDE.md</em></p>
</body>
</html>

